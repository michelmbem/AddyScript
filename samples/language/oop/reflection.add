function dumpScope(scope)
{
	switch (scope)
	{
		case "Private":
			print(" - ");
			break;
		case "Protected":
			print(" # ");
			break;
		case "Public":
			print(" + ");
			break;
	}
}

function dumpModifier(modifier)
{
	switch (modifier)
	{
		case "StaticFinal":
			println(" [SF]");
			break;
		case "Static":
			println(" [S]");
			break;
		case "Final":
			println(" [F]");
			break;
		case "Abstract":
			println(" [A]");
			break;
		default:
			println();
	}
}

function dumpField(field)
{
	dumpScope(field.scope);
	print(field.fullName);
	dumpModifier(field.modifier);
}

function dumpProperty($property)
{
	dumpScope($property.scope);
	print($property.fullName);
	
	print(" {");
	if ($property.canRead) {
		dumpScope($property.reader.scope);
		print("read;");
	}
	if ($property.canWrite) {
		dumpScope($property.writer.scope);
		print("write;");
	}
	print(" }");
	
	dumpModifier($property.modifier);
}

function dumpParameter(parameter)
{
	if (parameter.byRef)
		print("&");
	else if (parameter.vaList)
		print("..");
	
	print(parameter.name);
	
	if (!parameter.canBeEmpty)
		print("!");
	
	var defVal = parameter.defaultValue;
	if (defVal is string)
		print(" = '" + defVal.replace("'", "\\'") + "'");
	else if (defVal !== null)
		print(" = " + defVal);
}

function dumpMethod(method)
{
	dumpScope(method.scope);
	print(method.fullName);
	
	print("(");
	var comma = false;
	foreach (parameter in method.parameters)
	{
		if (comma) print(", ");
		dumpParameter(parameter);
		comma = true;
	}
	print(")");
	
	dumpModifier(method.modifier);
}

function dumpEvent(_event)
{
	dumpScope(_event.scope);
	print(_event.fullName);
	
	print("(");
	var comma = false;
	foreach (parameter in _event.parameters)
	{
		if (comma) print(", ");
		dumpParameter(parameter);
		comma = true;
	}
	print(")");
	
	dumpModifier(_event.modifier);
}

function underline(msg)
{
	println(msg);
	println('-' * msg.length);
}

function doubleLine()
{
	println();
	println('=' * 40);
	println();
}

function reflect(type, otherType)
{
	var title = type.name;
	for (var t = type.superType; t !== null; t = t.superType)
		title += " < " + t.name;
	underline(title);
	
	println($"isIntegral: {type.isIntegral}");
	println($"isNumeric: {type.isNumeric}");
	println($"isTemporal: {type.isTemporal}");
	println($"isSequential: {type.isSequential}");
	println($"isCollection: {type.isCollection}");
	println($"isSubclassOf({otherType.name}): {type.isSubclassOf(otherType)}");
	println($"isSuperClassOf({otherType.name}): {otherType.isSubclassOf(type)}");
	println($"isAssignableTo({otherType.name}): {type.isAssignableTo(otherType)}");
	println($"isAssignableFrom({otherType.name}): {type.isAssignableFrom(otherType)}");
	
	println();
	underline("contructor:");
	dumpMethod(type.$constructor);
	
	if (type.indexer !== null) {
		println();
		underline("indexer:");
		dumpProperty(type.indexer);
	}
	
	println();
	underline("fields:");
	foreach (field in type.fields)
		dumpField(field);
	
	println();
	underline("properties:");
	foreach ($property in type.properties)
		dumpProperty($property);
	
	println();
	underline("methods:");
	foreach (method in type.methods)
		dumpMethod(method);
	
	println();
	underline("events:");
	foreach (_event in type.events)
		dumpEvent(_event);
}

function manipulate()
{
	underline('Manipulating types by reflection:');
	
	type = typeof(Point);
	inst = type.newInstance(7, -3);
	(x, y) = (type.properties['x'].getValue(inst), type.properties['y'].getValue(inst));
	println($'The point is located at ({x}, {y})');
	type.methods['add_moved'].invoke(inst, |p| => println($'The point has moved to ({p.x}, {p.y})'));
	type.methods['move'].invoke(inst, -5, 2);
	
	type = typeof(Range);
	inst = type.newInstance(0, 10, 2);
	values = type.methods['toList'].invoke(inst);
	println($'Values produced by the range: {values}');
	item = type.indexer.getItem(inst, 2);
	println($'Range item #2: {item}');
	
	type = typeof(complex);
	inst = type.methods['of'].invoke(null, 2, 4);
	println($'The complex number created is: {inst}');
}

if (__name == 'main')
{
	// Make the point.add script available for import
	__context.AddImportPath('../../../samples/language/oop');
	
	import point;
	reflect(typeof(Point3D), typeof(Point));
	doubleLine();
	
	import std::xrange;
	reflect(typeof(Range), typeof(list));
	doubleLine();
	
	reflect(typeof(complex), typeof(float));
	doubleLine();
	
	reflect(typeof(int), typeof(long));
	doubleLine();
	
	reflect(typeof(list), typeof(tuple));
	doubleLine();
	
	manipulate();
	readln();
}