class Range
{
	private final start;
	private final end;
	private final step;
	private current;
	
	public constructor(start, end, step)
	{
		if (step <= 0) throw 'step has to be positive';
		
		this.start = min(start, end);
		this.end = max(start, end);
		this.step = step;
	}
	
	public property size => (int)((this.end - this.start) / this.step);
	
	public property []
	{
		read
		{
			if (__key < 0 || __key >= this.size)
				throw $'index {__key} is out of range; it should be between 0 and {this.size - 1}';
				
			return this.start + this.step * __key;
		}
	}
	
	public function moveFirst()
	{
		this.current = this.start;
	}
	
	public function hasNext() => this.current < this.end;
	
	public function moveNext()
	{
		var current = this.current;
		this.current += this.step;
		return current;
	}
	
	/**
	* This is a complementary method to make a range
	* behave like any other collection.
	*/
	public function each(action)
	{
		var item;
		foreach (item in this) action(item);
		return this;
	}
	
	public function toTuple() => (..this);
	
	public function toList() => [..this];
	
	public function toSet() => {..this};
}

function xrange(start, end = 0, step = 1) => new Range(start, end, step);

if (__name == 'main')
{
	var start = int(readln('range start (0): ') ?? '0');
	var end = int(readln('range end (10): ') ?? '10');
	var step = int(readln('range step (2): ') ?? '2');
	var r = xrange(start, end, step);
	
	print('range items: ');
	for (i = 0; i < r.size; ++i)
		print($'{r[i]} ');
	println();
	
	print('range items incremented by 1: ');
	r.each(|v| => print('{0} ', v + 1));
	println();
	
	println('range as a tuple: ' + r.toTuple());
	println('range as a list: ' + r.toList());
	println('range as a set: ' + r.toSet());
	
	readln();
}