<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccessDenied" xml:space="preserve">
    <value>Impossible d'accéder à {0} à partir de {1}</value>
  </data>
  <data name="AccessDenied3" xml:space="preserve">
    <value>Impossible d'accéder à {0} à partir de {1}</value>
  </data>
  <data name="AccessDenied2" xml:space="preserve">
    <value>Impossible d'accéder à {0} à partir de {1}</value>
  </data>
  <data name="AccessDenied1" xml:space="preserve">
    <value>Impossible d'accéder à {0} à partir de {1}</value>
  </data>
  <data name="CannotAlterConstant" xml:space="preserve">
    <value>Impossible de modifier un objet constant</value>
  </data>
  <data name="AttributesNotSupported" xml:space="preserve">
    <value>L'instruction suivante ne supporte pas les attributs</value>
  </data>
  <data name="IndexNotFound" xml:space="preserve">
    <value>La collection ne contient pas d'élément de rang {0}</value>
  </data>
  <data name="CaseLabelRequired" xml:space="preserve">
    <value>Un bloc 'switch' doit contenir au moins une étiquette 'case'</value>
  </data>
  <data name="CannotCreateSubclass" xml:space="preserve">
    <value>Impossible d'hériter de la classe finale ou statique {0}</value>
  </data>
  <data name="CannotCreateInstance" xml:space="preserve">
    <value>Impossible de créer une instance de la classe statique ou abstraite {0}</value>
  </data>
  <data name="OnlyBoolIntOrString" xml:space="preserve">
    <value>Attendue: une valeur de type booléen, entier ou chaîne</value>
  </data>
  <data name="NoBreakOutOfLoop" xml:space="preserve">
    <value>Le mot clé 'break' ne peut figurer qu'à l'intérieur d'une boucle ou d'un bloc 'switch'</value>
  </data>
  <data name="CannotConvert" xml:space="preserve">
    <value>Impossible de convertir de {0} à {1}</value>
  </data>
  <data name="CannotConvertFrom" xml:space="preserve">
    <value>La conversion automatique depuis {0} n'est pas prise en charge</value>
  </data>
  <data name="CannotConvertTo" xml:space="preserve">
    <value>Impossible de convertir l'expression vers {0}</value>
  </data>
  <data name="CannotJumpOutOfFinallyBlock" xml:space="preserve">
    <value>Impossible de faire un saut en dehors du bloc 'finally'</value>
  </data>
  <data name="CannotReturnFromFinallyBlock" xml:space="preserve">
    <value>L'instruction 'return' est illégale à l'intérieur du bloc 'finally'</value>
  </data>
  <data name="ConstructorCantReturnValue" xml:space="preserve">
    <value>Le constructeur ne peut pas retourner de valeur</value>
  </data>
  <data name="NoContinueOutOfLoop" xml:space="preserve">
    <value>Le mot clé 'continue' ne peut être utilisé qu'à l'intérieur d'une boucle</value>
  </data>
  <data name="DuplicatedAttribute" xml:space="preserve">
    <value>Chaque attribut doit être unique dans la liste</value>
  </data>
  <data name="DuplicatedAttributeProperty" xml:space="preserve">
    <value>Chaque propriété de l'attribut doit être unique</value>
  </data>
  <data name="DuplicatedCaseLabel" xml:space="preserve">
    <value>Chaque étiquette 'case' doit être unique dans un bloc 'switch'</value>
  </data>
  <data name="DuplicatedProperty" xml:space="preserve">
    <value>Chaque propriété de l'objet doit être unique</value>
  </data>
  <data name="DuplicatedKey" xml:space="preserve">
    <value>Chaque élément d'une carte doit avoir une clé unique</value>
  </data>
  <data name="DuplicatedLabel" xml:space="preserve">
    <value>L'étiquette {0} est déjà déclarée dans la portée courante</value>
  </data>
  <data name="DuplicatedVariable" xml:space="preserve">
    <value>Chaque variable doit être unique dans sa portée</value>
  </data>
  <data name="DuplicatedParameter" xml:space="preserve">
    <value>Chaque paramètre doit être unique dans la liste</value>
  </data>
  <data name="ExpressionRequired" xml:space="preserve">
    <value>Expression attendue</value>
  </data>
  <data name="FieldDeclaredInAncestor" xml:space="preserve">
    <value>Le champ {0} est déjà défini dans l'ancêtre {1}</value>
  </data>
  <data name="FieldHidesHomonymous" xml:space="preserve">
    <value>Le champ {0} masque une propiété, une méthode ou un évènement hérité du même nom</value>
  </data>
  <data name="PropertyNotFoundInClass" xml:space="preserve">
    <value>Il n'y a pas de propriété {0} dans la classe {1}</value>
  </data>
  <data name="PropertyNotFoundInObject" xml:space="preserve">
    <value>L'objet n'a pas de propriété {0}</value>
  </data>
  <data name="PropertyUsedAsMethod" xml:space="preserve">
    <value>{0} est une propriété mais est invoqué comme une méthode</value>
  </data>
  <data name="InvalidEvalParam" xml:space="preserve">
    <value>La chaîne fournie ne contient pas d'expression valide</value>
  </data>
  <data name="InvalidFieldModifier" xml:space="preserve">
    <value>Le modificateur {0} n'est pas applicable aux champs</value>
  </data>
  <data name="InvalidListTermination" xml:space="preserve">
    <value>Terminaison de liste incorrecte</value>
  </data>
  <data name="InvalidLValue" xml:space="preserve">
    <value>L'opérande de gauche n'est pas une adresse</value>
  </data>
  <data name="InvalidMemberModifier" xml:space="preserve">
    <value>Modificateur inapproprié pour le membre {0}. Seul 'final' conviendrait</value>
  </data>
  <data name="InvalidNewUsage" xml:space="preserve">
    <value>L'expression se termine incorrectement; un initialiseur d'objet ou un appel de constructeur est attendu</value>
  </data>
  <data name="InvalidTypeReference" xml:space="preserve">
    <value>Référence de type externe incorrecte: {0}</value>
  </data>
  <data name="IterationNotSupported" xml:space="preserve">
    <value>Impossible d'énumérer une variable de type {0}</value>
  </data>
  <data name="LiteralRequired" xml:space="preserve">
    <value>L'expression doit être une valeur litérale</value>
  </data>
  <data name="MandatoryParamsPrecede" xml:space="preserve">
    <value>Un paramètre obligatoire ne peut suivre un paramètre optionnel</value>
  </data>
  <data name="MemberNameConfict" xml:space="preserve">
    <value>Un autre membre est déjà déclaré avec le nom {0}</value>
  </data>
  <data name="MemberCantOverride" xml:space="preserve">
    <value>Le membre {0} ne peut pas être redéfini</value>
  </data>
  <data name="MethodHidesHomonymous" xml:space="preserve">
    <value>La méthode {0} masque un champ, une propriété ou un évènement hérité du même nom</value>
  </data>
  <data name="MethodNotFound" xml:space="preserve">
    <value>Il n'y a pas de méthode {0} dans la classe {1}</value>
  </data>
  <data name="MethodUsedAsProperty" xml:space="preserve">
    <value>{0} est une méthode mais est utilisée comme un propriété</value>
  </data>
  <data name="MissingDeclaringTypeProperty" xml:space="preserve">
    <value>Il manque un champ 'declaringType' dans l'attribut 'Method'</value>
  </data>
  <data name="MissingLabel" xml:space="preserve">
    <value>L'étiquette {0} n'est pas déclarée dans la portée en cours</value>
  </data>
  <data name="MissingMethodAttribute" xml:space="preserve">
    <value>Un attribut 'Method' devrait être attaché à la fonction {0}</value>
  </data>
  <data name="ModuleNotFound" xml:space="preserve">
    <value>Impossible de charger le module {0}. Vérifier que la propriété 'SearchPath' de l'objet ScriptContext est  correctement initialisée</value>
  </data>
  <data name="MustMatchSignature" xml:space="preserve">
    <value>{0} devrait avoir la même signature que {1}</value>
  </data>
  <data name="MustOverride" xml:space="preserve">
    <value>{0} devrait soit surcharger {1}, soit être marquée comme classe abstraite</value>
  </data>
  <data name="NameConflict" xml:space="preserve">
    <value>Le nom {0} sert déjà à identifier un autre objet</value>
  </data>
  <data name="JumpToCaseLabelOutOfSwitchBlock" xml:space="preserve">
    <value>Le script essaie de faire un saut vers une étiquette de cas en dehors d'un bloc switch</value>
  </data>
  <data name="NoMatchingIndexer" xml:space="preserve">
    <value>Impossible de trouver l'indexeur correspondant dans {0}</value>
  </data>
  <data name="NoMatchingProperty" xml:space="preserve">
    <value>Impossible de trouver la propriété correspondante dans {0}</value>
  </data>
  <data name="NonStaticMember" xml:space="preserve">
    <value>{0} n'est pas statique</value>
  </data>
  <data name="NotAReference" xml:space="preserve">
    <value>L'expression donnée n'est pas une référence</value>
  </data>
  <data name="NotAVariable" xml:space="preserve">
    <value>{0} n'est pas une variable</value>
  </data>
  <data name="NotEnumerable" xml:space="preserve">
    <value>Le type de l'objet n'est pas énumérable</value>
  </data>
  <data name="OperatorCantBeApplied" xml:space="preserve">
    <value>L'opérateur {0} n'est pas applicable au type {1}</value>
  </data>
  <data name="StatementRequired" xml:space="preserve">
    <value>Un instruction est attendue</value>
  </data>
  <data name="SingleConstructor" xml:space="preserve">
    <value>La classe a déjà un constructeur</value>
  </data>
  <data name="StaticClassHasNoSuperClass" xml:space="preserve">
    <value>Une classe statique ne peut hériter d'une autre. Choisir entre le retrait du modificateur 'static' et la suppression de la clause d'héritage</value>
  </data>
  <data name="StaticClassMember" xml:space="preserve">
    <value>Tout membre d'une classe statique doit également être statique</value>
  </data>
  <data name="StringsAreImmutable" xml:space="preserve">
    <value>Les chaînes sont immuables</value>
  </data>
  <data name="SuperUsedOutOfMethod" xml:space="preserve">
    <value>L'usage du mot-clé 'super' est illégal en dehors du corps d'une méthode</value>
  </data>
  <data name="ThisUsedOutOfMethod" xml:space="preserve">
    <value>L'usage du mot-clé 'this' est illégal en dehors du corps d'une méthode non-statique</value>
  </data>
  <data name="TooFewArgs" xml:space="preserve">
    <value>Pas assez d'arguments pour un appel à {0}</value>
  </data>
  <data name="TooManyArgs" xml:space="preserve">
    <value>Trop d'arguments pour un appel à {0}</value>
  </data>
  <data name="TypeNameExpected" xml:space="preserve">
    <value>Nom de type réquis</value>
  </data>
  <data name="UnableToFindMethod" xml:space="preserve">
    <value>Impossible de trouver la méthode correspondante dans {0}</value>
  </data>
  <data name="UndefinedFunction" xml:space="preserve">
    <value>La fonction {0} n'existe pas</value>
  </data>
  <data name="UndefinedType" xml:space="preserve">
    <value>Le type ou l'espace de noms {0} n'existe pas</value>
  </data>
  <data name="UndefinedVariable" xml:space="preserve">
    <value>La variable {0} n'existe pas</value>
  </data>
  <data name="UnexpectedToken" xml:space="preserve">
    <value>Rencontre inopportune du symbole {0}</value>
  </data>
  <data name="UnorderedType" xml:space="preserve">
    <value>Le type {0} n'a pas d'ordre prédéfini</value>
  </data>
  <data name="UseParserForInlineFuncs" xml:space="preserve">
    <value>Bien vouloir utiliser Parser pour la reconnaissance des "fonctions en-ligne"</value>
  </data>
  <data name="VaArgsMustBeTheLast" xml:space="preserve">
    <value>Une liste d'aguments de longueur variable doit toujours figurer en fin de liste</value>
  </data>
  <data name="CannotInvokeAbstractMember" xml:space="preserve">
    <value>Impossible d'invoquer le membre abstrait {0}</value>
  </data>
  <data name="ClassHasNoProperty" xml:space="preserve">
    <value>Le type {0} n'a aucune propriété</value>
  </data>
  <data name="ClassHasNoIndexer" xml:space="preserve">
    <value>Le type {0} n'a aucun indexeur</value>
  </data>
  <data name="MissingAttribute" xml:space="preserve">
    <value>Aucun attribut '{0}' n'est associé à la fonction externe {1}</value>
  </data>
  <data name="MissingAttributeProperty" xml:space="preserve">
    <value>Il manque un champ '{0}' dans la définition de l'attribut '{1}'</value>
  </data>
  <data name="UnresolvedMemberRef" xml:space="preserve">
    <value>Impossible de résoudre la référence au membre: {0}</value>
  </data>
  <data name="ScriptCannotReturnValue" xml:space="preserve">
    <value>Le script ne peut pas retourner de valeur</value>
  </data>
  <data name="TypeDoesNotSupportFunction" xml:space="preserve">
    <value>La fonction {0} n'accepte pas d'argument du type {1}</value>
  </data>
  <data name="InvalidDatePart" xml:space="preserve">
    <value>'{0}' n'est pas valide comme partie de date. Seuls 'year', 'month', 'yearday', 'weekday', 'day', 'hour', 'minute', 'second' and 'millisecond' sont acceptés.</value>
  </data>
  <data name="AbstractMethodInNonAbstractClass" xml:space="preserve">
    <value>Une classe non-abstraite ne saurait avoir une méthode abstraite</value>
  </data>
  <data name="UninitializedVariable" xml:space="preserve">
    <value>La variable {0} n'a pas encore été initialisée</value>
  </data>
  <data name="DuplicatedConstant" xml:space="preserve">
    <value>Chaque constante doit être unique</value>
  </data>
  <data name="DuplicatedItem" xml:space="preserve">
    <value>Chaque élément doit être unique</value>
  </data>
  <data name="InvalidConstantType" xml:space="preserve">
    <value>Une constante ne peut pas être du type {0}. Seuls bool, int, long, float, decimal, complex, date et string sont acceptés</value>
  </data>
  <data name="ObjectInInvalidState" xml:space="preserve">
    <value>L'object est dans un état intermédiaire.
Il a besoin d'une initialisation pour supporter l'opération sollicitée.</value>
  </data>
  <data name="FALSE" xml:space="preserve">
    <value>Faux</value>
  </data>
  <data name="TRUE" xml:space="preserve">
    <value>Vrai</value>
  </data>
  <data name="InvalidDateUnit" xml:space="preserve">
    <value>'{0}' n'est pas une unité de temps valide. Seuls 'year', 'month', 'day', 'hour', 'minute', 'second' et 'millisecond' sont acceptées.</value>
  </data>
  <data name="MissingClosingParen" xml:space="preserve">
    <value>Parenthèse fermante attendue</value>
  </data>
  <data name="BadDateCreateCall" xml:space="preserve">
    <value>date::create attend 3, 4, 6 ou 7 arguments. Le nombre d'arguments ({0}) fourni est invalide.</value>
  </data>
  <data name="SingleCharExpected" xml:space="preserve">
    <value>L'argument {0} de la fonction {1} doit être un caractère unique</value>
  </data>
  <data name="ArgMustBeOfType" xml:space="preserve">
    <value>L'argument {0} de la fonction {1} doit être de type {2}</value>
  </data>
  <data name="CannotAccessAbstractProperty" xml:space="preserve">
    <value>Impossible d'accéder à la propriété abstraite {0}</value>
  </data>
  <data name="CannotReadProperty" xml:space="preserve">
    <value>Impossible de lire une propriété en écriture seule</value>
  </data>
  <data name="CannotWriteProperty" xml:space="preserve">
    <value>Impossible d'écrire une propriété en lecture seule</value>
  </data>
  <data name="PropertyHidesHomonymous" xml:space="preserve">
    <value>La propriété {0} masque un champ, une méthode ou un évènement hérité du même nom</value>
  </data>
  <data name="InvalidAccessorsScope" xml:space="preserve">
    <value>Au moins, l'un des accesseurs doit avoir la même portée que la propriété elle-même</value>
  </data>
  <data name="NoEmptyProperty" xml:space="preserve">
    <value>La propriété doit définir un accesseur au moins</value>
  </data>
  <data name="EventDeclaredInAncestor" xml:space="preserve">
    <value>L'évènement {0} est déjà déclaré dans l'ancêtre {1}</value>
  </data>
  <data name="EventHidesHomonymous" xml:space="preserve">
    <value>L'évènement {0} masque un champ, une propriété ou une méthode hérité du même nom</value>
  </data>
  <data name="AccessorScopeMustBeMoreRestrictive" xml:space="preserve">
    <value>La portée d'un accesseur doit être plus restrictive que la portée de la propriété</value>
  </data>
  <data name="DuplicatedReadAccessor" xml:space="preserve">
    <value>Un accesseur en lecture a déjà été défini pour la propriété</value>
  </data>
  <data name="DuplicatedWriteAccessor" xml:space="preserve">
    <value>Un accesseur en écriture a déjà été défini pour la propriété</value>
  </data>
  <data name="InvalidOperandCount" xml:space="preserve">
    <value>Nombre d'opérandes invalide pour l'opérateur {0}</value>
  </data>
  <data name="UnoverloadableOperator" xml:space="preserve">
    <value>{0} n'est pas un opérateur surchargeable</value>
  </data>
  <data name="InvalidOperatorModifier" xml:space="preserve">
    <value>Aucun modificateur ne doit être précisé pour une surcharge d'opérateur</value>
  </data>
  <data name="CalleeIsNotClosure" xml:space="preserve">
    <value>L'expression fournie n'est pas une fermeture</value>
  </data>
  <data name="CannotWriteFinalField" xml:space="preserve">
    <value>Impossible de changer la valeur d'un champ final</value>
  </data>
  <data name="SpecificFieldModifier" xml:space="preserve">
    <value>La combinaison des modificateurs 'static' et 'final' ne peut être appliquée qu'à un champ</value>
  </data>
  <data name="InvalidConstructorModifier" xml:space="preserve">
    <value>Aucun modificateur ne doit être précisé pour le constructeur</value>
  </data>
  <data name="ConstantFieldShouldBeInitialized" xml:space="preserve">
    <value>Un champ constant doit être initialisé dès sa déclaration</value>
  </data>
  <data name="PackInvalidFormat" xml:space="preserve">
    <value>Format invalide pour un appel à pack ou unpack</value>
  </data>
  <data name="PackValuesDontMatchFormat" xml:space="preserve">
    <value>Le nombre de valeurs fournies ne correspond pas au nombre de spécificateurs définis dans le format</value>
  </data>
  <data name="ValueShouldNotBeEmpty" xml:space="preserve">
    <value>La valeur de l'objet ne peut être vide</value>
  </data>
  <data name="DuplicateRBraceInFormtString" xml:space="preserve">
    <value>Le caractère '}' doit être dupliqué dans les chaînes formattées</value>
  </data>
  <data name="SingleIndexer" xml:space="preserve">
    <value>La classe a déjà un indexeur</value>
  </data>
  <data name="IndexerCantBeStatic" xml:space="preserve">
    <value>Indexeur ne peut pas être static</value>
  </data>
  <data name="IndexerCantBeAuto" xml:space="preserve">
    <value>La génération automatique d'accesseurs n'est pas prise en charge pour les indexeurs</value>
  </data>
  <data name="FunctionHasNoParameterNamed" xml:space="preserve">
    <value>{0} ne possède pas de paramètre nommé {1}</value>
  </data>
  <data name="ParameterIsNotOptional" xml:space="preserve">
    <value>Le paramètre {0} de {1} n'est pas optionnel</value>
  </data>
  <data name="ParameterSuppliedTwice" xml:space="preserve">
    <value>Plusieurs arguments sont fournis pour le paramètre {0}</value>
  </data>
  <data name="AbstractMemberCantHaveBody" xml:space="preserve">
    <value>Un membre abstrait ne peut pas avoir de corps</value>
  </data>
  <data name="MissingPameter" xml:space="preserve">
    <value>Aucun argument n'est fourni pour le paramètre {0} de {1}</value>
  </data>
  <data name="CatchOrFinallyBlockRequired" xml:space="preserve">
    <value>Une instruction try sans resource devrait avoir un bloc try ou un bloc finally</value>
  </data>
  <data name="MissingClosingBrace" xml:space="preserve">
    <value>Il manque un '}'</value>
  </data>
  <data name="InvalidOperandForWith" xml:space="preserve">
    <value>L'operande de gauche de 'with' doit être un objet</value>
  </data>
</root>