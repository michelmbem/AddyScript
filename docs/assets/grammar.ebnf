Program ::= StatementWithLabels*

StatementWithLabels ::= Label* Statement

Label ::= IDENTIFIER ':'

Statement ::= ImportDirective
            | ClassDefinition
            | FunctionDecl
            | ExternalFunctionDecl
            | ConstantDecl
            | VariableDecl
            | Block
            | IfElse
            | SwitchBlock
            | ForLoop
            | ForEachLoop
            | WhileLoop
            | DoLoop
            | Continue
            | Break
            | Goto
            | Yield
            | Return
            | Throw
            | TryCatchFinally
            | AssignmentWithLet
            | (Expression ';')

ImportDirective ::= 'import' QualifiedName ('as' IDENTIFIER)? ';'

QualifiedName ::= IDENTIFIER ('::' IDENTIFIER)*

ClassDefinition ::= Attributes? MODIFIER? 'class' IDENTIFIER (':' IDENTIFIER)? '{' ClassMember* '}'

Attributes ::= '[' Attribute (',' Attribute)* ']'

Attribute ::= IDENTIFIER ('(' (Expression? | ((Expression ',')? VariableSetterList)) ')')?

ClassMember ::= MemberPrefix? MemberSpec

MemberPrefix ::= Attributes? ((SCOPE MODIFIER?)? | (MODIFIER SCOPE?)?)

MemberSpec ::= ConstructorSpec | FieldSpec | PropertySpec | MethodSpec | OperatorSpec | EventSpec

ConstructorSpec ::= 'constructor' ParameterList Block

ParameterList ::= '(' (Parameter (',' Parameter)*)? ')'

Parameter ::= Attributes? ('&' | '..')? IDENTIFIER '!'? ('=' Literal)?

Literal ::= 'null' | BOOLEAN | INTEGER | BIG_INTEGER | FLOAT | BIG_DECIMAL | COMPLEX | DATE | STRING | BLOB

FieldSpec ::= IDENTIFIER ('=' Expression)? ';'

PropertySpec ::= 'property' (IDENTIFIER | '[]') ((('=>' Expression)? ';') | ('{' ((SCOPE? 'read' MethodBody (SCOPE? 'write' MethodBody)?) | (SCOPE? 'write' MethodBody (SCOPE? 'read' MethodBody)?)) '}'))

MethodBody ::= (('=>' Expression)? ';') | Block

MethodSpec ::= 'function' IDENTIFIER ParameterList MethodBody

OperatorSpec ::= 'operator' OverloadableOperator ParameterList MethodBody

OverloadableOperator ::= '+' | '-' | '++' | '--' | '~' | '*' | '/' | '%' | '**' | '&' | '|' | '^' | '<<' | '>>' | '==' | '!=' | '<' | '>' | '<=' | '>=' | 'startswith' | 'endswith' | 'contains' | 'matches'

EventSpec ::= 'event' ParameterList ';'

FunctionDecl ::= Attributes? 'function' IDENTIFIER ParameterList FunctionBody

FunctionBody ::= ('=>' Expression ';') | Block

ExternalFunctionDecl ::= Attributes? 'extern' 'function' IDENTIFIER ParameterList ';'

VariableSetterList ::= VariableSetter (',' VariableSetter)*

VariableSetter ::= IDENTIFIER '=' Expression

ConstantDecl ::= 'const' VariableSetterList ';'

VariableDecl ::= 'var' VariableSetterList ';'

Block ::= '{' StatementWithLabels* '}'

IfElse ::= 'if' '(' Expression ')' Statement ('else' Statement)?

SwitchBlock ::= 'switch' '(' Expression ')' '{' (CaseLabel ':' StatementWithLabels*)* ('default' ':' StatementWithLabels*)? '}'

CaseLabel ::= 'case' (BOOLEAN | INTEGER | STRING)

ForLoop ::= 'for' '(' (VariableDecl | ExpressionList)? ';' Expression? ';' ExpressionList? ')' Statement

ExpressionList ::= Expression (',' Expression)*

ForEachLoop ::= 'foreach' '(' (IDENTIFIER '=>')? IDENTIFIER 'in' Expression ')' Statement

WhileLoop ::= 'while' '(' Expression ')' Statement

DoLoop ::= 'do' Statement 'while' '(' Expression ')' ';'

Continue ::= 'continue' ';'

Break ::= 'break' ';'

Goto ::= 'goto' (IDENTIFIER | ('case' (BOOLEAN | INTEGER | STRING)) | 'default') ';'

Yield ::= 'yield' Expression ';'

Return ::= 'return' Expression? ';'

Throw ::= 'throw' Expression ';'

TryCatchFinally ::= 'try' ('(' Expression ')')? Block ('catch' '(' IDENTIFIER ')' Block)? ('finally' Block)?

AssignmentWithLet ::= 'let' Reference '=' Expression ';'

Reference ::= VariableRef | ItemRef | SliceRef | PropertyRef | StaticPropertyRef | ParentPropertyRef | ParentIndexerRef | TupleInitializer | SetInitializer

Expression ::= Assignment

Assignment ::= TernaryExpression (AssignmentOperator Assignment)*

AssignmentOperator ::= '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '**=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '??='

TernaryExpression ::= Condition ('?' Expression ':' Expression)?

Condition ::= Relation (LogicalOperator Relation)*

LogicalOperator ::= '&' | '&&' | '|' | '||' | '^' | '??'

Relation ::= Term ((RelationalOperator Term) | ('is' 'not'? Pattern))?

RelationalOperator ::= '==' | '!=' | '<' | '>' | '<=' | '>=' | '===' | '!==' | 'startswith' | 'endswith' | 'contains' | 'matches' | 'not'? 'in'

Term ::= Factor (('+' | '-') Factor)*

Factor ::= Exponentiation (('*' | '/' | '%' | '<<' | '>>') Exponentiation)*

Exponentiation ::= PostfixUnaryExpression ('**' Exponentiation)*

PostfixUnaryExpression ::= PrefixUnaryExpression ('++' | '--' | '!')*

PrefixUnaryExpression ::= ('+' | '-' | '~' | '!' | '++' | '--')* Composite

Composite ::= Atom (('[' (Expression | (Expression? '..' Expression?)) ']') | ('.' IDENTIFIER ArgumentList?) | ArgumentList | ('switch' '{' MatchCaseList '}') | ('with' '{' VariableSetterList '}'))*

ArgumentList ::= '(' (Arguments (',' NamedArgList)? | NamedArgList)? ')'

Arguments ::= Argument (',' Argument)*

Argument ::= '..'? Expression

NamedArgList ::= NamedArg (',' NamedArg)*

NamedArg ::= IDENTIFIER ':' Expression

MatchCaseList ::= MatchCase (',' MatchCase)*

MatchCase ::= Pattern ('when' Expression)? '=>' MatchCaseExpression

Pattern ::= '_' | 'null' | ('>' | '<' | ">=" | "<=")? ValuePattern | "matches" STRING | TYPE_NAME (('(' IDENTIFIER (',' IDENTIFIER)* ')') | ObjectPattern)? | ObjectPattern | NegativePattern | LogicalPattern | GroupingPattern | MUTABLE_STRING

ValuePattern ::= ([+-]? (INTEGER | BIG_INTEGER | FLOAT | BIG_DECIMAL)) | BOOLEAN | DATE | STRING

ObjectPattern ::= '{' IDENTIFIER ':' Pattern (',' IDENTIFIER ':' Pattern)* '}'

NegativePattern ::= 'not' Pattern

LogicalPattern ::= Pattern (('or' | 'and') Pattern)+

GroupingPattern ::= '(' Pattern ')'

MatchCaseExpression ::= Block | 'throw'? Expression

Atom ::= Literal | MUTABLE_STRING | 'this' | AtomStartingWithSuper | AtomStartingWithTypeOf | AtomStartingWithTypeName | AtomStartingWithId | AtomStartingWithNew | AtomStartingWithLParen | AtomStartingWithLBrace | ListInitializer | Lambda | InlineFunction

AtomStartingWithSuper ::= 'super' (('::' IDENTIFIER ArgumentList?) | ('[' Expression ']'))

AtomStartingWithTypeOf ::= 'typeof' '(' (TYPE_NAME | IDENTIFIER) ')'

AtomStartingWithTypeName ::= TYPE_NAME '::' IDENTIFIER ArgumentList?

AtomStartingWithId ::= QualifiedName ArgumentList?

AtomStartingWithNew ::= ObjectInitializer | ConstructorCall

ObjectInitializer ::= 'new' '{' VariableSetterList? '}'

ConstructorCall ::= 'new' QualifiedName ((ArgumentList ('{' VariableSetterList? '}')?) | ('{' VariableSetterList? '}'))

AtomStartingWithLParen ::= Conversion | TupleInitializer | ParenthesizedExpression

Conversion ::= '(' TYPE_NAME ')' Expression

TupleInitializer ::= '(' Arguments ','? ')'

ParenthesizedExpression ::= '(' Expression ')'

AtomStartingWithLBrace ::= SetInitializer | MapInitializer

SetInitializer ::= '{' Arguments? '}'

MapInitializer ::= '{' (MapItemInitializerList | '=>') '}'

MapItemInitializerList ::= MapItemInitializer (',' MapItemInitializer)*

MapItemInitializer ::= Expression '=>' Expression

ListInitializer ::= '[' Arguments? ']'

Lambda ::= '|' (Parameter (',' Parameter)*)? '|' '=>' ((Expression ';') | Block)

InlineFunction ::= 'function' ParameterList Block

LETTER ::= ('A'-'Z') | ('a'-'z')

LETTER_EXTENDED ::= LETTER | '_' | ('\xc0'-'\xd6') | ('\xd8'-'\xf6') | ('\xf8'-'\xff')

DIGIT ::= '0'-'9'

HEXDIGIT ::= DIGIT | ('A'-'F') | ('a'-'f')

IDENTIFIER ::= STANDARD_IDENTIFIER | SPECIAL_IDENTIFIER

STANDARD_IDENTIFIER ::= LETTER_EXTENDED (LETTER_EXTENDED | DIGIT)*

SPECIAL_IDENTIFIER ::= '$' (LETTER_EXTENDED | DIGIT | ESCAPE_SEQ)+

ESCAPE_SEQ ::= '\a' | '\b' | '\f' | '\n' | '\r' | '\t' | '\v' | (('\x'  | ('\u' HEXDIGIT HEXDIGIT)) HEXDIGIT HEXDIGIT)

BOOLEAN ::= 'true' | 'false'

INTEGER ::= DECIMAL_INTEGER | HEX_INTEGER

DECIMAL_INTEGER ::= (DIGIT ('_' DIGIT)*)+

HEX_INTEGER ::= '0' [Xx] HEXDIGIT+

BIG_INTEGER ::= INTEGER [Ll]

REAL ::= (('.' DECIMAL_INTEGER) | (DECIMAL_INTEGER ('.' DECIMAL_INTEGER)?)) (('e' | 'E') ('+' | '-')? DECIMAL_INTEGER)?

FLOAT ::= REAL [Ff]?

BIG_DECIMAL ::= REAL [Dd]

COMPLEX ::= REAL [iI]

DATE ::= '`' [^`]* '`'

MUTABLE_STRING ::= '$' STRING

STRING ::= '@'? (SINGLE_QUOTED | DOUBLE_QUOTED)

BLOB ::= [bB](SINGLE_QUOTED | DOUBLE_QUOTED)

SINGLE_QUOTED ::= "'" ( [^'] | ESCAPE_SEQ)* "'"

DOUBLE_QUOTED ::= '"' ([^"] | ESCAPE_SEQ)* '"'

TYPE_NAME ::= 'void' | 'bool' | 'int' | 'long' | 'rational' | 'float' | 'decimal' | 'complex' | 'date' | 'duration' | 'string' | 'list' | 'map' | 'set' | 'queue' | 'stack' | 'object' | 'resource' | 'closure'

MODIFIER ::= 'final' | 'static' | 'abstract'

SCOPE ::= 'private' | 'protected' | 'public'