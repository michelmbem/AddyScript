Program ::= StatementSeries

StatementSeries ::= (Label* Statement)*

Label ::= IDENTIFIER ':'

Statement ::= ImportDirective | ClassDefinition | FunctionDecl | ExternalFunctionDecl | ConstantDecl | VariableDecl | Block | IfElse | SwitchBlock | ForLoop | ForEachLoop | WhileLoop | DoLoop | Continue | Break | Goto | Return | Throw | TryCatchFinally | (Expression ';')

ImportDirective ::= "import" QualifiedName ("as" IDENTIFIER)? ';'

QualifiedName ::= IDENTIFIER ("::" IDENTIFIER)*

ClassDefinition ::= Attributes? MODIFIER? "class" IDENTIFIER (':' IDENTIFIER)? '{' ClassMember* '}'

Attributes ::= '[' Attribute (',' Attribute)* ']'

Attribute ::= IDENTIFIER ('(' (Expression? | ((Expression ',')? PropertyInitializers)) ')')?

PropertyInitializers ::= PropertyInitializer (',' PropertyInitializer)*

PropertyInitializer ::= IDENTIFIER '=' Expression

ClassMember ::= MemberPrefix? MemberSpec

MemberPrefix ::= (SCOPE ((MODIFIER Attributes?)? | (Attributes MODIFIER?)?)) | (MODIFIER ((SCOPE Attributes?)? |(Attributes SCOPE?)?)) | (Attributes ((SCOPE MODIFIER?)? | (MODIFIER SCOPE?)?))

MemberSpec ::= ConstructorSpec | FieldSpec | PropertySpec | MethodSpec | EventSpec

ConstructorSpec ::= "constructor" ParameterList Block

FieldSpec ::= IDENTIFIER ('=' Expression)? ';'

PropertySpec ::= "property" PropertyName (ExpandedPropertySpec | AutoPropertySpec)

PropertyName ::= IDENTIFIER | "[]"

ExpandedPropertySpec ::= ("=>" Expression ';') | ('{' (SCOPE? ("read" | "write") FunctionBody)+ '}')

FunctionBody ::= ("=>" Expression ';') | Block

AutoPropertySpec ::= ('{' (SCOPE? ("read" | "write") ';')+ '}') | ';'

MethodSpec ::= AbstractMethodSpec | StandardMethodSpec | OperatorSpec

AbstractMethodSpec ::= "function" IDENTIFIER ParameterList ';'

StandardMethodSpec ::= "function" IDENTIFIER ParameterList FunctionBody

OperatorSpec ::= "operator" OverloadableOperator ParameterList FunctionBody

ParameterList ::= '(' (Parameter (',' Parameter)*)? ')'

Parameter ::= (ParameterPrefix IDENTIFIER) | (IDENTIFIER ('=' Literal)?)

ParameterPrefix ::= "ref" | "params"

OverloadableOperator ::= '+' | '-' | "++" | "--" | '~' | '*' | '/' | '%' | "**" | '&' | '|' | '^' | "<<" | ">>" | "==" | "!=" | '<' | '>' | "<=" | ">=" | "startswith" | "endswith" | "contains" | "matches"

EventSpec ::= "event" ParameterList ';'

FunctionDecl ::= Attributes? "function" IDENTIFIER ParameterList FunctionBody

ExternalFunctionDecl ::= Attributes? "extern" "function" IDENTIFIER ParameterList ';'

ConstantDecl ::= "const" PropertyInitializers ';'

VariableDecl ::= "var" PropertyInitializers ';'

Block ::= '{' StatementSeries '}'

IfElse ::= "if" '(' Expression ')' Statement ("else" Statement)?

SwitchBlock ::= "switch" '(' Expression ')' '{' (CaseLabel StatementSeries)+ '}'

CaseLabel ::= (("case" (BOOLEAN | INTEGER | STRING)) | "default") ':'

ForLoop ::= "for" '(' (VariableDecl | ExpressionList)? ';' Expression? ';' ExpressionList? ')' Statement

ExpressionList ::= Expression (',' Expression)*

ForEachLoop ::= "foreach" '(' (IDENTIFIER "=>")? IDENTIFIER "in" Expression ')' Statement

WhileLoop ::= "while" '(' Expression ')' Statement

DoLoop ::= "do" Statement "while" '(' Expression ')' ';'

Continue ::= "continue" ';'

Break ::= "break" ';'

Goto ::= "goto" IDENTIFIER ';'

Return ::= "return" Expression? ';'

Throw ::= "throw" Expression ';'

TryCatchFinally ::= "try" ('(' Expression ')')? Block ("catch" '(' IDENTIFIER ')' Block)? ("finally" Block)?

Expression ::= Assignment

Assignment ::= TernaryExpression (AssignmentOperator Assignment)*

AssignmentOperator ::= '=' | "+=" | "-=" | "*=" | "/=" | "%=" | "**=" | "&=" | "|=" | "^=" | "<<=" | ">>=" | "??="

TernaryExpression ::= Condition ('?' Expression ':' Expression)?

Condition ::= Relation (LogicalOperator Relation)*

LogicalOperator ::= '&' | "&&" | '|' | "||" | '^' | "??"

Relation ::= Term ((RelationalOperator Term) | ("is" (TYPE_NAME | IDENTIFIER)))?

RelationalOperator ::= "==" | "!=" | '<' | '>' | "<=" | ">=" | "===" | "!==" | "startswith" | "endswith" | "contains" | "matches"

Term ::= Factor (('+' | '-') Factor)*

Factor ::= Exponentiation (('*' | '/' | '%' | "<<" | ">>") Exponentiation)*

Exponentiation ::= PostfixUnaryExpression ("**" Exponentiation)*

PostfixUnaryExpression ::= PrefixUnaryExpression ("++" | "--" | '!')*

PrefixUnaryExpression ::= ('+' | '-' | '~' | '!' | "++" | "--")* Composite

Composite ::= Atom (('[' (Expression | (Expression? ".." Expression?)) ']') | ('.' IDENTIFIER ArgumentList?) | ArgumentList | ("switch" '{' MatchCases '}') | ("with" '{' PropertyInitializers '}'))*

ArgumentList ::= '(' (ExpressionList (',' NamedArgList)? | NamedArgList)? ')'

NamedArgList ::= NamedArg (',' NamedArg)*

NamedArg ::= IDENTIFIER ':' Expression

MatchCases ::= MatchCase (',' MatchCase)*

MatchCase ::= Pattern "=>" MatchCaseExpression

Pattern ::= '_' | "null" | (TYPE_NAME ObjectPattern?) | ObjectPattern | ValuePattern | RangePattern | PredicatePattern | CompositePattern

ObjectPattern ::= '{' IDENTIFIER '=' ValuePattern (',' IDENTIFIER '=' ValuePattern)* '}'

ValuePattern ::= ('+' | '-')? (BOOLEAN | INTEGER | BIG_INTEGER | FLOAT | BIG_DECIMAL | DATE | STRING)

RangePattern ::= (ValuePattern ".." ValuePattern?) | (".." ValuePattern)

PredicatePattern ::= IDENTIFIER ':' Expression

CompositePattern ::= Pattern (',' Pattern)+

MatchCaseExpression ::= Block | "throw"? Expression

Atom ::= Literal | "this" | AtomStartingWithSuper | AtomStartingWithTypeOf | AtomStartingWithTypeName | AtomStartingWithId | AtomStartingWithNew | AtomStartingWithLParen | AtomStartingWithLBrace | ListInitializer | Lambda | InlineFunction

Literal ::= "null" | BOOLEAN | INTEGER | BIG_INTEGER | FLOAT | BIG_DECIMAL | DATE | STRING

AtomStartingWithSuper ::= "super" (("::" IDENTIFIER ArgumentList?) | ('[' Expression ']'))

AtomStartingWithTypeOf ::= "typeof" '(' (TYPE_NAME | IDENTIFIER) ')'

AtomStartingWithTypeName ::= TYPE_NAME "::" IDENTIFIER ArgumentList?

AtomStartingWithId ::= QualifiedName ArgumentList?

AtomStartingWithNew ::= ObjectInitializer | ConstructorCall

ObjectInitializer ::= "new" '{' PropertyInitializers? '}'

ConstructorCall ::= "new" QualifiedName ArgumentList? ('{' PropertyInitializers? '}')?

AtomStartingWithLParen ::= Conversion | ComplexInitializer | ParenthesizedExpression

Conversion ::= '(' TYPE_NAME ')' Expression

ComplexInitializer ::= '(' Expression ',' Expression ')'

ParenthesizedExpression ::= '(' Expression ')'

AtomStartingWithLBrace ::= SetInitializer | MapInitializer

SetInitializer ::= '{' ExpressionList? '}'

MapInitializer ::= '{' (MapItemInitializers | "=>") '}'

MapItemInitializers ::= MapItemInitializer (',' MapItemInitializer)*

MapItemInitializer ::= Expression "=>" Expression

ListInitializer ::= '[' ExpressionList? ']'

Lambda ::= '|' (Parameter (',' Parameter)*)? '|' "=>" FunctionBody

InlineFunction ::= "function" ParameterList Block

LETTER ::= ('A'-'Z') | ('a'-'z')

LETTER_EXTENDED ::= LETTER | '_' | ('\xc0'-'\xd6') | ('\xd8'-'\xf6') | ('\xf8'-'\xff')

DIGIT ::= '0'-'9'

HEXDIGIT ::= DIGIT | ('A'-'F') | ('a'-'f')

IDENTIFIER ::= STANDARD_IDENTIFIER | SPECIAL_IDENTIFIER

STANDARD_IDENTIFIER ::= LETTER_EXTENDED (LETTER_EXTENDED | DIGIT)*

SPECIAL_IDENTIFIER ::= '$' (LETTER_EXTENDED | DIGIT | ESCAPE_SEQ)+

ESCAPE_SEQ ::= "\a" | "\b" | "\f" | "\n" | "\r" | "\t" | "\v" | (("\x"  | ("\u" HEXDIGIT HEXDIGIT)) HEXDIGIT HEXDIGIT)

BOOLEAN ::= "true" | "false"

INTEGER ::= DECIMAL_INTEGER | HEX_INTEGER

DECIMAL_INTEGER ::= (DIGIT ('_' DIGIT)*)+

HEX_INTEGER ::= ("0x" | "0X") HEXDIGIT+

BIG_INTEGER ::= INTEGER ('l' | 'L')

FLOAT ::= DECIMAL_INTEGER ('.' DECIMAL_INTEGER)? (('e' | 'E') ('+' | '-')? DECIMAL_INTEGER)? ('f' | 'F')?

BIG_DECIMAL ::= DECIMAL_INTEGER ('.' DECIMAL_INTEGER)? (('e' | 'E') ('+' | '-')? DECIMAL_INTEGER)? ('d' | 'D')

DATE ::= '`' [^`]* '`'

STRING ::= ('$''@'?)? (SINGLE_QUOTED | DOUBLE_QUOTED)

SINGLE_QUOTED ::= "'" ( [^'] | ESCAPE_SEQ)* "'"

DOUBLE_QUOTED ::= '"' ([^"] | ESCAPE_SEQ)* '"'

TYPE_NAME ::= "void" | "bool" | "int" | "long" | "rational" | "float" | "decimal" | "complex" | "date" | "string" | "list" | "map" | "set" | "queue" | "stack" | "object" | "resource" | "closure"

MODIFIER ::= "final" | "static" | "abstract"

SCOPE ::= "private" | "protected" | "public"